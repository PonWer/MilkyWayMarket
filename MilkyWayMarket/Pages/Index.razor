@page "/"
@using System.Globalization
@using System.Collections
@inject IDataService DataService

<PageTitle>Index</PageTitle>

<RadzenRow JustifyContent="JustifyContent.Normal" AlignItems="AlignItems.Center" Gap="1rem" class="rz-border-info-light">
	<RadzenDropDown @bind-Value=@selectectedValue
					Data=@items
					TextProperty="ItemName"
					ValueProperty="ItemIndex"
					Multiple=true
					AllowClear=true
					AllowFiltering="true"
					FilterCaseSensitivity="FilterCaseSensitivity.CaseInsensitive"
					Placeholder="Select items"
					Chips=true
					Disabled="@(!DataService.Initiated)"
					Style="width: 100%; max-width: 400px;" />
	<RadzenButton style="width: 160px" Icon="search" BusyText="Loading ..." IsBusy=@DataService.Busy Click=@OnBusyClick Text="Search" Disabled="@(!DataService.Initiated)" />
</RadzenRow>

@*
<RadzenRow JustifyContent="JustifyContent.Normal" AlignItems="AlignItems.Center" Gap="1rem" class="rz-border-info-light">
	<RadzenStack Orientation="Orientation.Vertical" AlignItems="AlignItems.Center" Gap="0rem">
	<RadzenText Text="Start Date" class="rz-text-capitalize" />
	<RadzenDatePicker @bind-Value=@startDate Change="@DateRangeChanged" InitialViewDate="DateTime.Now" YearRange="2023:2023" ShowTime="false" Max="DateTime.Today" DateFormat="dd/MM/yyyy" />
	</RadzenStack>

	<RadzenStack Orientation="Orientation.Vertical" AlignItems="AlignItems.Center" Gap="0rem">
	<RadzenText Text="End Date" class="rz-text-capitalize" />
	<RadzenDatePicker @bind-Value=@endDate Change="@DateRangeChanged" InitialViewDate="DateTime.Now" YearRange="2023:2023" ShowTime="false" Max="DateTime.Today.AddDays(1)" DateFormat="dd/MM/yyyy" />
	</RadzenStack>

	<RadzenStack Orientation="Orientation.Vertical" AlignItems="AlignItems.Center" Gap="0rem">
		<RadzenText Text="Smooth lines" class="rz-text-capitalize" />
		<RadzenSwitch @bind-Value=@smooth Disabled="@(!DataService.Initiated)" Change="SettingsChangedCallback" />
	</RadzenStack>

	<RadzenStack Orientation="Orientation.Vertical" AlignItems="AlignItems.Center" Gap="0rem">
		<RadzenText Text="Show Data Labels" class="rz-text-capitalize" />
		<RadzenSwitch @bind-Value=@showDataLabels Disabled="@(!DataService.Initiated)" Change="SettingsChangedCallback" />
	</RadzenStack>
</RadzenRow>
*@

<RadzenRow JustifyContent="JustifyContent.Normal" AlignItems="AlignItems.Center" Gap="1rem" class="rz-border-info-light">
	<RadzenButton style="width: 80px" IsBusy=@DataService.Busy Click=@(() => SetTimeLine(TimeLine.Day)) Text="Day" Disabled="@(!DataService.Initiated)" />
	<RadzenButton style="width: 80px" IsBusy=@DataService.Busy Click=@(() => SetTimeLine(TimeLine.Week)) Text="Week" Disabled="@(!DataService.Initiated)" />
	<RadzenButton style="width: 80px" IsBusy=@DataService.Busy Click=@(() => SetTimeLine(TimeLine.Month)) Text="Month" Disabled="@(!DataService.Initiated)" />
	<RadzenButton style="width: 160px" IsBusy=@DataService.Busy Click=@(() => SetTimeLine(TimeLine.ThreeMonths)) Text="Three Months" Disabled="@(!DataService.Initiated)" />
	<RadzenButton style="width: 80px" IsBusy=@DataService.Busy Click=@(() => SetTimeLine(TimeLine.Year)) Text="Year" Disabled="@(!DataService.Initiated)" />
	<RadzenButton style="width: 80px" IsBusy=@DataService.Busy Click=@(() => SetTimeLine(TimeLine.All)) Text="All" Disabled="@(!DataService.Initiated)" />
</RadzenRow>

@if (items.Any())
{
	<RadzenChart>
		@foreach (var data in dataSets)
		{
			<RadzenLineSeries Smooth="@smooth" Data="@data.Value" CategoryProperty="Date" Title="@data.Key" LineType="LineType.Dashed" ValueProperty="Ask">
				<RadzenMarkers MarkerType="MarkerType.Square" />
				<RadzenSeriesDataLabels Visible="@showDataLabels" />
				@* 			<TooltipTemplate Context="item">
		<div>
		Ask for <span>@item.Date</span> 2020:
		<strong>@item.Ask</strong>
		</div>
		</TooltipTemplate> *@
			</RadzenLineSeries>
		}
		<RadzenCategoryAxis>
			<RadzenTicks>
				<Template>
					<text class="rz-tick-text" style="text-anchor: start; transform: translate(@(context.X)px, @(context.Y + 10)px) rotate(45deg)">@context.Value</text>
				</Template>
			</RadzenTicks>
		</RadzenCategoryAxis>
		<RadzenValueAxis Min="0" Step="@StepValue">
			<RadzenGridLines Visible="true" />
			<RadzenAxisTitle Text="Ask" />

		</RadzenValueAxis>
	</RadzenChart>


}
@code
{
	enum TimeLine
	{
		Day,
		Week,
		Month,
		ThreeMonths,
		Year,
		All
	}


	IList<int> selectectedValue = new int[] { };
	Dictionary<string, List<DataItem>> dataSets = new Dictionary<string, List<DataItem>>();
	List<itemKey> items = new List<itemKey>();
	TimeLine timeLine = TimeLine.Day;

	bool smooth = false;
	bool showDataLabels = true;

	double StepValue = 1;

	class DataItem
	{
		public string Date { get; set; }
		public double Ask { get; set; }
	}

	async Task OnBusyClick()
	{
		if (!selectectedValue.Any())
			return;

		await DataService.Query(selectectedValue.Select(x => items[x].ItemName).ToList());
	}

	protected override async Task OnInitializedAsync()
	{
		DataService.DataUpdated += (sender, message) =>
		{
			UpdateList();
			UpdateChartData();

			StateHasChanged();
		};

		UpdateList();
	}

	private void UpdateChartData()
	{
		if (DataService.Busy)
			return;

		if (!selectectedValue.Any())
			return;

		foreach (var dataSet in dataSets)
		{
			dataSet.Value.Clear();
		}

		foreach (var selected in selectectedValue)
		{
			var key = items[selected].ItemName;
			dataSets.TryAdd(key, new List<DataItem>());

			var list = new List<DataItem>();

			if (!DataService.History.ContainsKey(key))
				return;

			foreach (var itemHistory in GetTimeLineElements(key))
			{
				if (StepValue < itemHistory.Value.Ask)
					StepValue = itemHistory.Value.Ask;

				var item = new DataItem()
					{
						Date = itemHistory.Key,
						Ask = itemHistory.Value.Ask,
					};

				list.Add(item);
			}

			StepValue = Math.Floor(StepValue / 3f);

			if (StepValue <= 0)
				StepValue = 1;

			dataSets[key].AddRange(list);
		}

		StateHasChanged();
	}

	private IEnumerable<KeyValuePair<string, Item>> GetTimeLineElements(string key)
	{
		IEnumerable<KeyValuePair<DateTime, Item>> matchingPeriod = DataService.History[key].history
			.OrderBy(x => x.Key);

		switch (timeLine)
		{
			case TimeLine.Day:
				matchingPeriod = matchingPeriod.Where(x => DateTime.Today.AddDays(-1) <= x.Key);

				if (matchingPeriod == null || !matchingPeriod.Any()) return new List<KeyValuePair<string, Item>>();

				Console.WriteLine($"{TimeLine.Day} elements found {matchingPeriod.Count()} " +
										$"between {DateTime.Today.AddDays(-1)} and (latest element){matchingPeriod.Last().Key.ToString()}");
				break;
			case TimeLine.Week:
				matchingPeriod = matchingPeriod.Where(x => DateTime.Today.AddDays(-7) <= x.Key);

				if (matchingPeriod == null || !matchingPeriod.Any()) return new List<KeyValuePair<string, Item>>();

				Console.WriteLine($"{TimeLine.Week} elements found {matchingPeriod.Count()} " +
										$"between {DateTime.Today.AddDays(-7)} and (latest element){matchingPeriod.Last().Key.ToString()}");

				break;
			case TimeLine.Month:
				matchingPeriod = matchingPeriod.Where(x => DateTime.Today.AddMonths(-1) <= x.Key);

				if (matchingPeriod == null || !matchingPeriod.Any()) return new List<KeyValuePair<string, Item>>();

				Console.WriteLine($"{TimeLine.Month} elements found {matchingPeriod.Count()} " +
										$"between {DateTime.Today.AddMonths(-1)} and (latest element){matchingPeriod.Last().Key.ToString()}");

				break;
			case TimeLine.ThreeMonths:
				matchingPeriod = matchingPeriod.Where(x => DateTime.Today.AddMonths(-3) <= x.Key);

				if (matchingPeriod == null || !matchingPeriod.Any()) return new List<KeyValuePair<string, Item>>();

				Console.WriteLine($"{TimeLine.ThreeMonths} elements found {matchingPeriod.Count()} " +
										$"between {DateTime.Today.AddMonths(-3)} and (latest element){matchingPeriod.Last().Key.ToString()}");

				break;
			case TimeLine.Year:

				if (matchingPeriod == null || !matchingPeriod.Any()) return new List<KeyValuePair<string, Item>>();

				matchingPeriod = matchingPeriod.Where(x => DateTime.Today.AddYears(-1) <= x.Key);
				Console.WriteLine($"{TimeLine.Year} elements found {matchingPeriod.Count()} " +
										$"between {DateTime.Today.AddYears(-1)} and (latest element){matchingPeriod.Last().Key.ToString()}");

				break;
			case TimeLine.All:

				if (matchingPeriod == null || !matchingPeriod.Any()) return new List<KeyValuePair<string, Item>>();

				Console.WriteLine($"{TimeLine.All} elements found {matchingPeriod.Count()}, (latest element){matchingPeriod.Last().Key.ToString()}");

				break;
			default:
				throw new ArgumentOutOfRangeException();
		}

		var returnDictionary = new Dictionary<string, Item>();
		switch (timeLine)
		{
			case TimeLine.Day:

				foreach (var pair in matchingPeriod)
				{
					returnDictionary.Add(pair.Key.ToShortTimeString(), pair.Value);
				}
				break;
			case TimeLine.Week:

				foreach (var groupedOnDate in matchingPeriod.GroupBy(x => x.Key.Date))
				{
					for (int i = 0; i <= 24; i += 3)
					{
						var startHour = i - 3;
						var endHour = i;

						var timeSpan = groupedOnDate.Where(x => startHour <= x.Key.Hour && x.Key.Hour < endHour).ToList();

						if (!timeSpan.Any())
						{
							Console.WriteLine($"None found for {groupedOnDate.Key} between {startHour} and {endHour}");
							continue;
						}

						returnDictionary.Add(
								timeSpan.First().Key.ToString("dd/MM HH"), new Item()
									{
										Ask = Math.Floor(timeSpan.Average(x => x.Value.Ask))
									});

					}
				}

				break;
			case TimeLine.Month:
				foreach (var groupedOnDate in matchingPeriod.GroupBy(x => x.Key.Date))
				{
					returnDictionary.Add(groupedOnDate.Key.ToString("dd/MM"), new Item()
						{
							Ask = Math.Floor(groupedOnDate.Average(x => x.Value.Ask))
						});
				}
				break;
			case TimeLine.ThreeMonths:

				foreach (var groupedOnDate in matchingPeriod.GroupBy(x => x.Key.Date))
				{
					for (int i = 0; i <= 30; i += 10)
					{
						var startDay = i - 10;
						var endDay = i;

						var timeSpan = groupedOnDate.Where(x => startDay <= x.Key.Day && x.Key.Day < endDay).ToList();

						if (!timeSpan.Any())
						{
							Console.WriteLine($"None found for {groupedOnDate.Key} between {startDay} and {endDay}");
							continue;
						}

						returnDictionary.Add(
							timeSpan.First().Key.ToString("dd/MM"), new Item()
								{
									Ask = Math.Floor(timeSpan.Average(x => x.Value.Ask))
								});

					}
				}
				break;
			case TimeLine.Year:
				foreach (var groupedOnDate in matchingPeriod.GroupBy(x => x.Key.Month))
				{
					returnDictionary.Add(groupedOnDate.First().Key.ToString("MMM yyyy", CultureInfo.InvariantCulture), new Item()
						{
							Ask = Math.Floor(groupedOnDate.Average(x => x.Value.Ask))
						});
				}
				break;
			case TimeLine.All:
				foreach (var groupedOnDate in matchingPeriod.GroupBy(x => x.Key.Month))
				{
					returnDictionary.Add(groupedOnDate.First().Key.ToString("MMM yyyy", CultureInfo.InvariantCulture), new Item()
						{
							Ask = Math.Floor(groupedOnDate.Average(x => x.Value.Ask))
						});
				}
				break;
			default:
				throw new ArgumentOutOfRangeException();
		}
		return returnDictionary;
	}


	void SetTimeLine(TimeLine inTimeLine)
	{
		timeLine = inTimeLine;

		if (!selectectedValue.Any() || !dataSets.Any())
			return;

		UpdateChartData();
		StateHasChanged();
	}

	protected void UpdateList()
	{
		if (items.Any())
			return;

		items.Clear();
		foreach (var key in DataService.HistoryKeys)
		{
			items.Add(new itemKey()
				{
					ItemIndex = items.Count,
					ItemName = key
				});
		}

		StateHasChanged();
	}

	public class itemKey
	{
		public string ItemName { get; set; }
		public int ItemIndex { get; set; }
		public bool IsDisabled { get { return false; } }
	}

	private void DateRangeChanged()
	{
		UpdateChartData();
	}

	private void SettingsChangedCallback()
	{
		StateHasChanged();
	}
}

